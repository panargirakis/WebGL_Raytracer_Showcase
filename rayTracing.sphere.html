<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <title>WebGL Example File</title>


    <script id="vshader" type="x-shader/x-vertex">
        attribute vec3 aPosition;
        varying   vec3 vPosition;
        void main() {
            gl_Position = vec4(aPosition, 1.0);
            vPosition = aPosition;
        }
    </script>

    <script id="fshader" type="x-shader/x-fragment">
        uniform mediump float lightx;
        uniform mediump float lighty;
        precision mediump float;
        varying vec3 vPosition;

        struct Sphere {
            vec3 center;
            float radius;
            vec3 color;
        };

        struct Plane {
            vec3 origin;
            vec3 point;
            vec3 normal;
            vec3 color;
        };

        struct Ray {
            vec3 origin;
            vec3 direction;
        };

        struct Light {
            vec3 position;
            float ambience;
            vec3 specular;
            vec3 diffuse;
        };

        struct RayTracerOutput {
            Ray reflectedRay;
            Ray refractedRay;
            vec3 color;
        };

        Sphere spheres[4];
        Ray rays[1];
        Light light[1];
        Plane planes[1];

        void initialize() {
            float x = vPosition.x;
            float y = vPosition.y;
            float z = vPosition.z;
            float focalLength = 2.0;
            vec3 color = vec3(0.0, 0.0, 0.0);

            // Create spheres
            spheres[0].center = vec3(1, 1, -1.0);// location of sphere
            spheres[0].radius = 0.4;
            spheres[0].color = vec3(1.0, 0.0, 0.0);// color red

            spheres[1].center = vec3(-1.0, 1.0, -1.0);
            spheres[1].radius = 0.4;
            spheres[1].color = vec3(0.0, 1.0, 0.0);

            spheres[2].center = vec3(1.0, -1.0, -1.0);
            spheres[2].radius = 0.4;
            spheres[2].color = vec3(0.0, 0.0, 1.0);

            spheres[3].center = vec3(-1.0, -1.0, -1.0);
            spheres[3].radius = 0.4;
            spheres[3].color = vec3(0.5, 0.0, 0.5);

            planes[0].origin = vec3(0, 0, -5);
            //planes[0].point = vec3(0, 1, -1);
            planes[0].normal = vec3(0, 0, 1);
            planes[0].color = vec3(0.0, 0.5, 0.5);

            // Create ray
            rays[0].origin = vec3(lightx, lighty, focalLength);// emission point is the same distance back as the focal
            // length
            rays[0].direction = normalize(vec3(x, y, -focalLength));// the direction will be in the direction of this
            // specific pixel we're looking at

            // Create Light source
            light[0].position = vec3(0.0, 0.0, 0.9);
            light[0].ambience = 0.3;
        }

        float checkIntersectSphere(Sphere sphere, Ray ray) {
            vec3 sphereCenter = sphere.center;
            float radius = sphere.radius;
            vec3 cameraSource = ray.origin;
            vec3 cameraDirection = ray.direction;

            vec3 distanceFromCenter = (cameraSource - sphereCenter);
            float B = 2.0 * dot(cameraDirection, distanceFromCenter);
            float C = dot(distanceFromCenter, distanceFromCenter) - pow(radius, 2.0);
            float delta = pow(B, 2.0) - 4.0 * C;
            float t = 0.0;
            if (delta > 0.0) { // i know i have an intersection
                float sqRoot = sqrt(delta);
                float t1 = (-B + sqRoot) / 2.0;
                float t2 = (-B - sqRoot) / 2.0;
                t = min(t1, t2);
            }
            if (delta == 0.0) {
                t = -B / 2.0;
            }

            return t;
        }

        float checkIntersectPlane(Plane plane, Ray ray) {
            float t = 0.0;

            float divisor = dot(ray.direction, plane.normal);
            if (divisor != 0.0) {
                t = dot(plane.origin - ray.origin, plane.normal) / divisor;
            }

            return t;
        }

        RayTracerOutput getRay(Ray ray, Light light) {

            const float veryLargeNumber = 100000.0;
            const int numOfSpheres = 4;
            const int numOfPlanes = 1;
            RayTracerOutput rayTracer;
            Sphere sphereToShow;
            Plane planeToShow;
            vec3 color = vec3(0.0, 0.0, 0.0);
            float minTSphere = veryLargeNumber;
            float minTPlane = veryLargeNumber;

            // calculate which object is being shown
            for (int i=0; i < numOfSpheres; i++) { // go through all spheres, determine which one is on top
                float tSphere = 0.0;
                tSphere = checkIntersectSphere(spheres[i], ray);
                if (tSphere > 0.0 && tSphere < minTSphere) {
                    minTSphere = tSphere;
                    sphereToShow = spheres[i];
                }
            }
            for (int i=0; i < numOfPlanes; i++) { // go through all planes, determine which one is on top
                float tPlane = 0.0;
                tPlane = checkIntersectPlane(planes[i], ray);
                if (tPlane > 0.0 && tPlane < minTPlane) {
                    minTPlane = tPlane;
                    planeToShow = planes[i];
                }
            }

            bool drawSphere = minTSphere < minTPlane;
            float minT = drawSphere ? minTSphere : minTPlane;

            // calculate if an object is blocking
            float minTFromLight = veryLargeNumber;
            Ray lightRay;
            lightRay.origin = light.position;
            lightRay.direction = normalize((ray.origin + minT * ray.direction) - light.position);
            float tOfPointFromLightSource = drawSphere ? checkIntersectSphere(sphereToShow, lightRay) : checkIntersectPlane(planeToShow, lightRay);

            // clculate minT for any spheres or
            for (int i=0; i < numOfSpheres; i++) { // go through all spheres, determine which one is on top
                float tSphere = 0.0;
                tSphere = checkIntersectSphere(spheres[i], lightRay);
                if (tSphere > 0.0 && tSphere < minTFromLight) {
                    minTFromLight = tSphere;
                }
            }
            for (int i=0; i < numOfPlanes; i++) { // go through all planes, determine which one is on top
                float tPlane = 0.0;
                tPlane = checkIntersectPlane(planes[i], lightRay);
                if (tPlane > 0.0 && tPlane < minTFromLight) {
                    minTFromLight = tPlane;
                }
            }

            bool objectIsInShadow = minTFromLight < tOfPointFromLightSource;
            // bool objectIsInShadow = false;

            vec3 cameraSource = ray.origin;
            vec3 cameraDirection = ray.direction;
            vec3 lightSource = light.position;
            float ambience = light.ambience;
            Ray reflectionRay;
            Ray refractionRay;

            vec3 surfacePoint;
            vec3 surfaceNormal;

            if (minT > 0.0 && minT < veryLargeNumber) {

                if (drawSphere) {

                    vec3 sphereCenter = sphereToShow.center;
                    vec3 colorOfSphere = sphereToShow.color;

                    surfacePoint = cameraSource + (minT * cameraDirection);
                    surfaceNormal = normalize(surfacePoint - sphereCenter);
                    if (
                    objectIsInShadow) {
                        color = colorOfSphere * ambience; }
                    else {
                        color = colorOfSphere * (ambience + ((1.0 - ambience) * max(0.0, dot(surfaceNormal, lightSource)))); }
                }
                else { // if drawing a plane
                    surfacePoint = cameraSource + (minT * cameraDirection);
                    surfaceNormal = normalize(planeToShow.normal);
                    // if there is an object covering the light source
                    // color = colorOfPlane * ambiance
                    // else
                    if (objectIsInShadow) {
                        color = planeToShow.color * ambience; }
                    else {
                        color = planeToShow.color * (ambience + ((1.0 - ambience) * max(0.0, dot(surfaceNormal, lightSource)))); }
                }

                rayTracer.color = color;

                //Reflected ray TODO: add reflection -and- refraction
                // TODO: add recursion
                // vec3 reflection = refract(ray.direction, surfaceNormal, 0.95);
                vec3 reflection = reflect(ray.direction, surfaceNormal);
                reflectionRay.origin = surfacePoint + 0.0001 * surfaceNormal;
                reflectionRay.direction = reflection;
                rayTracer.reflectedRay = reflectionRay;

                vec3 refraction = refract(ray.direction, surfaceNormal, 0.98);
                refractionRay.origin = surfacePoint - 0.0001 * surfaceNormal;
                refractionRay.direction = refraction;
                rayTracer.refractedRay = refractionRay;

            }
            else {
                rayTracer.color = color;
            }

            return rayTracer;
        }

        void main() {
            const int reflectionDepth = 3;

            initialize();
            // RayTracerOutput mainRay = getRay(rays[0], light[0]);
            // RayTracerOutput reflectionRay = getRay(mainRay.reflectedRay, light[0]);
            // TODO: modify so that it is not just a sum and takes into account the properties of the surface. Perfect
            // mirror? Only kind of reflective?

            vec3 reflectionColor = vec3(0, 0, 0);
            vec3 refractionColor = vec3(0, 0, 0);
            vec3 mainRayColor;

            RayTracerOutput recursiveRays[reflectionDepth];
            recursiveRays[0] = getRay(rays[0], light[0]);
            mainRayColor = recursiveRays[0].color;

            for (int i = 1; i < reflectionDepth; i++) { // go through every reflected ray at each pixel
                recursiveRays[i] = getRay(recursiveRays[i-1].reflectedRay, light[0]);
                reflectionColor += recursiveRays[i].color;
            }
            for (int i = 1; i < reflectionDepth; i++) { // go through every refracted ray at each pixel
                recursiveRays[i] = getRay(recursiveRays[i-1].refractedRay, light[0]);
                refractionColor += recursiveRays[i].color;
            }
            gl_FragColor = vec4(mainRayColor + reflectionColor + refractionColor, 1.0);
        }
    </script>

    <script src="lib/webgl-utils.js"></script>
    <script src="lib/initShaders.js"></script>
    <script src="lib/MV.js"></script>

    <script src="example.js"></script>

</head>

<body onload="main()">

<canvas height="700" id="webgl" width="700">
    Please use a browser that supports the "canvas" tag.
</canvas>

</body>
</html>
